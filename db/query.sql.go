// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package database

import (
	"context"
	"database/sql"
)

const employeesCount = `-- name: EmployeesCount :one
SELECT COUNT(emp_id)
FROM employee
`

func (q *Queries) EmployeesCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, employeesCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const filterEmployeeBySalary = `-- name: FilterEmployeeBySalary :many
SELECT emp_id, first_name, last_name, birth_day, sex, salary, super_id, branch_id
FROM employee
WHERE salary >= $1 AND salary < $2
`

type FilterEmployeeBySalaryParams struct {
	Min sql.NullInt32
	Max sql.NullInt32
}

func (q *Queries) FilterEmployeeBySalary(ctx context.Context, arg FilterEmployeeBySalaryParams) ([]Employee, error) {
	rows, err := q.db.QueryContext(ctx, filterEmployeeBySalary, arg.Min, arg.Max)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Employee
	for rows.Next() {
		var i Employee
		if err := rows.Scan(
			&i.EmpID,
			&i.FirstName,
			&i.LastName,
			&i.BirthDay,
			&i.Sex,
			&i.Salary,
			&i.SuperID,
			&i.BranchID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const filterEmployeeBySalaryAndSex = `-- name: FilterEmployeeBySalaryAndSex :many
SELECT emp_id, first_name, last_name, birth_day, sex, salary, super_id, branch_id
FROM employee
WHERE salary >= $1 AND salary < $2
AND ($3::VARCHAR IS NULL OR sex = $3::VARCHAR)
`

type FilterEmployeeBySalaryAndSexParams struct {
	Min sql.NullInt32
	Max sql.NullInt32
	Sex string
}

func (q *Queries) FilterEmployeeBySalaryAndSex(ctx context.Context, arg FilterEmployeeBySalaryAndSexParams) ([]Employee, error) {
	rows, err := q.db.QueryContext(ctx, filterEmployeeBySalaryAndSex, arg.Min, arg.Max, arg.Sex)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Employee
	for rows.Next() {
		var i Employee
		if err := rows.Scan(
			&i.EmpID,
			&i.FirstName,
			&i.LastName,
			&i.BirthDay,
			&i.Sex,
			&i.Salary,
			&i.SuperID,
			&i.BranchID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const filterEmployeeBySex = `-- name: FilterEmployeeBySex :many
SELECT emp_id, first_name, last_name, birth_day, sex, salary, super_id, branch_id
FROM employee
WHERE sex = $1
`

func (q *Queries) FilterEmployeeBySex(ctx context.Context, sex sql.NullString) ([]Employee, error) {
	rows, err := q.db.QueryContext(ctx, filterEmployeeBySex, sex)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Employee
	for rows.Next() {
		var i Employee
		if err := rows.Scan(
			&i.EmpID,
			&i.FirstName,
			&i.LastName,
			&i.BirthDay,
			&i.Sex,
			&i.Salary,
			&i.SuperID,
			&i.BranchID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findEmployeeByName = `-- name: FindEmployeeByName :many
SELECT emp_id, first_name, last_name, birth_day, sex, salary, super_id, branch_id FROM employee WHERE first_name = $1
`

func (q *Queries) FindEmployeeByName(ctx context.Context, n sql.NullString) ([]Employee, error) {
	rows, err := q.db.QueryContext(ctx, findEmployeeByName, n)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Employee
	for rows.Next() {
		var i Employee
		if err := rows.Scan(
			&i.EmpID,
			&i.FirstName,
			&i.LastName,
			&i.BirthDay,
			&i.Sex,
			&i.Salary,
			&i.SuperID,
			&i.BranchID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClientbyBranch = `-- name: GetClientbyBranch :many
SELECT client.client_id, client_name, branch.branch_name
FROM client
JOIN branch
ON branch.branch_id = client.branch_id
WHERE branch.branch_name = $1::VARCHAR
`

type GetClientbyBranchRow struct {
	ClientID   int32
	ClientName sql.NullString
	BranchName sql.NullString
}

func (q *Queries) GetClientbyBranch(ctx context.Context, branch string) ([]GetClientbyBranchRow, error) {
	rows, err := q.db.QueryContext(ctx, getClientbyBranch, branch)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClientbyBranchRow
	for rows.Next() {
		var i GetClientbyBranchRow
		if err := rows.Scan(&i.ClientID, &i.ClientName, &i.BranchName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClientsByEmployee = `-- name: GetClientsByEmployee :many
SELECT c.client_id, c.client_name
FROM client c
JOIN branch b ON c.branch_id = b.branch_id
JOIN employee e ON b.mgr_id = e.emp_id
WHERE e.first_name = $1::VARCHAR
`

type GetClientsByEmployeeRow struct {
	ClientID   int32
	ClientName sql.NullString
}

func (q *Queries) GetClientsByEmployee(ctx context.Context, firstName string) ([]GetClientsByEmployeeRow, error) {
	rows, err := q.db.QueryContext(ctx, getClientsByEmployee, firstName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClientsByEmployeeRow
	for rows.Next() {
		var i GetClientsByEmployeeRow
		if err := rows.Scan(&i.ClientID, &i.ClientName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployeeByBranch = `-- name: GetEmployeeByBranch :many
SELECT employee.emp_id, employee.first_name, employee.last_name, branch.branch_name
FROM employee
JOIN branch
ON branch.branch_id = employee.branch_id
WHERE branch.branch_name = $1::VARCHAR
`

type GetEmployeeByBranchRow struct {
	EmpID      int32
	FirstName  sql.NullString
	LastName   sql.NullString
	BranchName sql.NullString
}

func (q *Queries) GetEmployeeByBranch(ctx context.Context, bName string) ([]GetEmployeeByBranchRow, error) {
	rows, err := q.db.QueryContext(ctx, getEmployeeByBranch, bName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmployeeByBranchRow
	for rows.Next() {
		var i GetEmployeeByBranchRow
		if err := rows.Scan(
			&i.EmpID,
			&i.FirstName,
			&i.LastName,
			&i.BranchName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployeeBySalesQtd = `-- name: GetEmployeeBySalesQtd :many
SELECT employee.first_name, employee.last_name
FROM employee
WHERE employee.emp_id IN (
    SELECT works_with.emp_id
    FROM works_with
    WHERE works_with.total_sales > $1::INT
    AND works_with.total_sales < $2::INT
)
`

type GetEmployeeBySalesQtdParams struct {
	Min int32
	Max int32
}

type GetEmployeeBySalesQtdRow struct {
	FirstName sql.NullString
	LastName  sql.NullString
}

func (q *Queries) GetEmployeeBySalesQtd(ctx context.Context, arg GetEmployeeBySalesQtdParams) ([]GetEmployeeBySalesQtdRow, error) {
	rows, err := q.db.QueryContext(ctx, getEmployeeBySalesQtd, arg.Min, arg.Max)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmployeeBySalesQtdRow
	for rows.Next() {
		var i GetEmployeeBySalesQtdRow
		if err := rows.Scan(&i.FirstName, &i.LastName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSupplierByType = `-- name: GetSupplierByType :many
SELECT branch_supplier.supplier_name, branch.branch_name, branch_supplier.supply_type
FROM branch_supplier
JOIN branch
ON branch_supplier.branch_id = branch.branch_id
WHERE branch_supplier.supply_type = $1::VARCHAR
`

type GetSupplierByTypeRow struct {
	SupplierName string
	BranchName   sql.NullString
	SupplyType   sql.NullString
}

func (q *Queries) GetSupplierByType(ctx context.Context, type_ string) ([]GetSupplierByTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, getSupplierByType, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSupplierByTypeRow
	for rows.Next() {
		var i GetSupplierByTypeRow
		if err := rows.Scan(&i.SupplierName, &i.BranchName, &i.SupplyType); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllEmployees = `-- name: ListAllEmployees :many
SELECT emp_id, first_name, last_name, birth_day, sex, salary, super_id, employee.branch_id, branch.branch_id, branch_name, mgr_id, mgr_start_date
FROM employee
LEFT JOIN branch
ON employee.emp_id = branch.mgr_id
`

type ListAllEmployeesRow struct {
	EmpID        int32
	FirstName    sql.NullString
	LastName     sql.NullString
	BirthDay     sql.NullTime
	Sex          sql.NullString
	Salary       sql.NullInt32
	SuperID      sql.NullInt32
	BranchID     sql.NullInt32
	BranchID_2   sql.NullInt32
	BranchName   sql.NullString
	MgrID        sql.NullInt32
	MgrStartDate sql.NullTime
}

// Get all employees including their branches
func (q *Queries) ListAllEmployees(ctx context.Context) ([]ListAllEmployeesRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllEmployees)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllEmployeesRow
	for rows.Next() {
		var i ListAllEmployeesRow
		if err := rows.Scan(
			&i.EmpID,
			&i.FirstName,
			&i.LastName,
			&i.BirthDay,
			&i.Sex,
			&i.Salary,
			&i.SuperID,
			&i.BranchID,
			&i.BranchID_2,
			&i.BranchName,
			&i.MgrID,
			&i.MgrStartDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllEmployeesBy = `-- name: ListAllEmployeesBy :many
SELECT emp_id, first_name, last_name, birth_day, sex, salary, super_id, employee.branch_id, branch.branch_id, branch_name, mgr_id, mgr_start_date
FROM employee
LEFT JOIN branch
ON employee.emp_id = branch.mgr_id
ORDER BY emp_id DESC
LIMIT $1
`

type ListAllEmployeesByRow struct {
	EmpID        int32
	FirstName    sql.NullString
	LastName     sql.NullString
	BirthDay     sql.NullTime
	Sex          sql.NullString
	Salary       sql.NullInt32
	SuperID      sql.NullInt32
	BranchID     sql.NullInt32
	BranchID_2   sql.NullInt32
	BranchName   sql.NullString
	MgrID        sql.NullInt32
	MgrStartDate sql.NullTime
}

// Get All employees by limit in order desc
func (q *Queries) ListAllEmployeesBy(ctx context.Context, limit int32) ([]ListAllEmployeesByRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllEmployeesBy, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllEmployeesByRow
	for rows.Next() {
		var i ListAllEmployeesByRow
		if err := rows.Scan(
			&i.EmpID,
			&i.FirstName,
			&i.LastName,
			&i.BirthDay,
			&i.Sex,
			&i.Salary,
			&i.SuperID,
			&i.BranchID,
			&i.BranchID_2,
			&i.BranchName,
			&i.MgrID,
			&i.MgrStartDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listManagers = `-- name: ListManagers :many
SELECT employee.emp_id, employee.first_name, branch.branch_name
FROM employee
JOIN branch
ON employee.emp_id = branch.mgr_id
`

type ListManagersRow struct {
	EmpID      int32
	FirstName  sql.NullString
	BranchName sql.NullString
}

func (q *Queries) ListManagers(ctx context.Context) ([]ListManagersRow, error) {
	rows, err := q.db.QueryContext(ctx, listManagers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListManagersRow
	for rows.Next() {
		var i ListManagersRow
		if err := rows.Scan(&i.EmpID, &i.FirstName, &i.BranchName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSalariesASC = `-- name: ListSalariesASC :many
SELECT emp_id, first_name, last_name, birth_day, sex, salary, super_id, branch_id
FROM employee
ORDER BY salary ASC
`

func (q *Queries) ListSalariesASC(ctx context.Context) ([]Employee, error) {
	rows, err := q.db.QueryContext(ctx, listSalariesASC)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Employee
	for rows.Next() {
		var i Employee
		if err := rows.Scan(
			&i.EmpID,
			&i.FirstName,
			&i.LastName,
			&i.BirthDay,
			&i.Sex,
			&i.Salary,
			&i.SuperID,
			&i.BranchID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSalariesDESC = `-- name: ListSalariesDESC :many
SELECT emp_id, first_name, last_name, birth_day, sex, salary, super_id, branch_id
FROM employee
ORDER BY salary DESC
`

func (q *Queries) ListSalariesDESC(ctx context.Context) ([]Employee, error) {
	rows, err := q.db.QueryContext(ctx, listSalariesDESC)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Employee
	for rows.Next() {
		var i Employee
		if err := rows.Scan(
			&i.EmpID,
			&i.FirstName,
			&i.LastName,
			&i.BirthDay,
			&i.Sex,
			&i.Salary,
			&i.SuperID,
			&i.BranchID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
